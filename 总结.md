# 滴滴短租项目总结
```Java
public enum ReserveOrderStatusEnum {

    待处理(0, "待处理"), 取消(1, "取消"), 无车(2, "无车"), 完成(3, "选车完成"),订单送达(4,"订单完成"),处理中(5,"处理中");

public enum CarStatusEnum {

    已下线(0), 不可用(1), 可预订(2), 订单预定中(10), 订单中(11), 调度预定中(20), 调度中(21), 默认(-1);

public enum TaskPoolStatus {
    TODO(0),        //待处理
    DOING(1),       //已经生成工单
    CANCEL(2),      //需要取消
    CANCELED(3),    //已取消
    FINISH(4),      //关联工单已经完成
    EXCEPTION(5),    //异常取消的工单
    FAIL(10);       //失败,创建出错

public enum RentTaskAttKeyEnum {

    KEY_RESERVE_DATE("reserveDate", "预约时间"),
    KEY_RESERVE_STATION_ID("reserveStationId", "预约场站id"),
    KEY_RESERVE_ORDER_ID("dzOrderId", "预约订单id"),
    KEY_CAR_BRAND_DICT_CODE("brandDictCode", "预约车型id"),
    KEY_SOURCE("source", "来源规则id"),
    KEY_CANCELLED_BY_TASK("cancelledByTask", "工单任务取消标记"),
    KEY_SEND_DISTANCE("sendDistance", "送车距离");


public class TaskPool {

    id; carUid; taskType; taskId;  source;

    // 状态0待处理 1生成工单 2取消 10失败
    private Integer status;

    //创建失败的次数
    private Integer wrapCount;

    private String ext;

    private String remark;

    private Date createTime;

    private Date updateTime;
```
## 一、总体阐述：
* 支持共享汽车短租送车服务，
	* 由C端发预约单（预约单ID+消息类型+时间+地点+车型）到 MQ1，B 端调度引擎监控到订单之后，存储在b_reserve_order。C端用户取消预约单，发送（预约单ID+消息类型）至MQ1。B端监控到取消订单之后，更新b_reserve_order。
		* 先从预约单表中找预约单信息，找到了，如果是待处理、完成、无车三种,都直接把reserve_order和task_pool的记录状态给置为[需取消]；消费者返回Result.SUCCESS
		* 否则如果是预约单的话，先找reserve_order里是否已经有这张表了，如果有，就无需再次放入直接返回Result.SUCCESS即可；否则就要生成预约单信息，放入表中，返回Result.SUCCESS
		* 消息格式是json。MsgBody msgBody = JSON.parseObject(message.getValue()
	* 之后调度引擎定时查表选取距预约时间2小时内的预约单，按预约场站，5km,10km,10km以外来查找符合条件的车辆，如果没有，就找预约场站是否有符合条件的有调度工单的车辆，没选中且距离预约时间不足1小时，则放入MQ2通知C端用户无车，选中则将信息放入工单池，由工单系统生成工单，由调度人员于调度APP上领取送车到预约场站。
* 主要职责：负责 B 端调度引擎的实现与测试。使用MQ代替http进行C端和B端的通信，达到解耦和异步化；使用分布式锁解决多机并发问题；由于真实数据的不可控，使用 Mockito 构造对象进行整体逻辑测试，Junit进行功能测试。
## 二、项目的扩展问题：
* 用消息中间件进行B端和C端的解耦，B端在各个流程节点，发送（预约单ID+消息类型+状态信息）至MQ2。包括预约前一个小时仍然查找不到车辆。C端获取需要的信息，通知用户【我们可以发送任何消息】
## 三、调度引擎处理预约单具体流程：
* 
* 1）预约时间过滤，需要距离现在2小时以内待处理的预约单，遍历处理预约单
	* 1、判断预约单是否是待处理状态，不是【说明已经被并发的其他线程处理过了或者正在处理】，就跳过，是就试图取获取该预约单的分布式锁
	* 2、获取失败就跳过该预约单【说明有线程在处理】，成功获取锁就更新预约单状态为处理中【为了并发的时候不用扫描到这个正在处理中的预约单，节约资源，如果没有这个处理中状态，那么只要我还没处理完，其余线程都会扫描到它并且试图取获取锁，分布式锁是有开销的】，处理这个预约单，记得失败要设置预约单状态为待处理。并且无论怎样，最后finally都要释放锁
		* 1. 预约场站是否有符合（车型，电量，状态）的车辆。并且要去除b_task_pool里待处理【这辆车已经被其他预约单用了】和具有防调用标识的车辆【属性表b_task_main_attribute中key为KEY_CANCELLED_BY_TASK工单任务取消标记，value为1，说明这辆车生成工单后被执行的过程中出现了问题，不能使用这辆车】 【当然，后面全城的汽车也要去除待处理和被短租送车工单标记为取消的车【工单系统会标记，这是个是防调用标识】】，在选择油量大于60的剩余电量最多的
		* 2. 查询全城可预约的汽车，将全城汽车分为距离该场站 5km，10km，大于10km 三堆【于是可以批量查询经纬度计算距离】【maybe可以戳戳这个算法】
		* 3. 判断5km的，电量大于60，相同电量同一场站区域优先【因为需要判断汽车所在的场站区域和场站组是否和预约单一样，为了减少数据库访问次数，所以也每小时定时执行做一个缓存map,场站ID->RentStationRegion】；判断 10 km 的，相同电量同一场站组优先；判断全城的，选择到达后剩余电量>60且最多的汽车
		* 4. 如果都没有，就查看当前场站区域符合的车辆【到达后剩余电量，车型】有无待领取调度工单【需是不占车的调度工单】，有则取消它。
		* 5. 如果综上找到了车，或者有可以取消的调度工单，就取消它【及身上所有不占车的工单？】【通过domino来扭转的状态，事件是取消】
			* 1. cancelTask（instance） :查询该任务下所有的子工单，更改子工单状态为已取消。然后更新任务状态为已取消
			* 2. 并且如果是短租的话？
		* 6. 短租调度事务：然后将预约单信息放入b_task_pool和b_task_main_attribute，放入成功则改变预约单状态为已完成；【怎么保证正确：你们可以一个预约单被运行多次，或者不同预约单找到同一辆车，只要你找到车后数据库只有一份数据；找到同一辆车：因为有唯一键，插入会失败自动回滚，不需要做处理；一个预约单被处理多次：则需要加锁】
			*  @Transactional(rollbackFor = {Exception.class})【doGenerateDispathTask自己编造】
			* 1. 查b_task_pool里是否有caruid的调度工单【假：caruid和tasktype组成了唯一键】，没有则插入[类型为调度，来源为短租，状态为todo，caruid]， 如果存在且状态为待处理，那么不更新，否则更新为待处理，；如果生成失败，我就扔异常【回滚】
			* 2. 删除调度下该车的所有属性，设置b_task_main_attribute表中的属性【】【预约时间，场站，订单，车型，来源，工单任务取消标记，送车距离】。失败就仍异常【回滚】。b_task_main_attribute  UNIQUE KEY `uniq_car_uid_task_type` (`car_uid`,`task_type`,`att_key`), 【用的mybatis的example,maybe可以用foreach  https://www.cnblogs.com/java-zhao/p/5594795.html】
			* 3. 更新reserve_order状态为完成。失败就仍异常【回滚】
		* 7. 如果没有找到车，且距离预约时间小于1小时，就构造apiService.doPost(url,参数map)【滴滴封装的HttpPost】,通知C端，告诉用户无车【只需要给个url，放入订单id即可】，然后更新reserve_order状态为无车【面试的时候说成改为将无车消息放入MQ2】

【工单系统会更新taskpool的信息】
## 四、项目遇到的困难
### 4.1 单机上由于并发时 两个不同的预约单（或者相同的）找到了同一辆车，并准备插入b_task_pool和b_task_main_attribute，放入成功则改变预约单状态为已完成，出现明明为null，却插入失败  【于是我就开始加锁】】
刚开始只考虑到了单机并发，因为刚开始预约单比较少，但正式的时候预约单比较多，所以到时候很可能这个定时任务就变成并发的了。做了一个生产者产生很多预约单，一个预约单处理时间大概是800ms，70/80个预约单就产生并发了。为了测试并发，我把定时时间改为5秒了，然后出现了并发问题。【如果两个（同一个）预约单并发找到了同一辆车，然后就报错，无法插入同一张表】

* 刚开始，是task_pool，没有caruid的调度工单【假：caruid tasktype是唯一键】，那么我就插入，如果存在并且状态不为待处理，我就更新，如果状态为待处理，我就扔异常【说明这辆车已经被别人占了，该预约单需要重新找车】。但是报错：DuplicateKeyException【重复，因为唯一键只能插入一次】
* 1. 明明查出来是null，但却插不进去。报DuplicateKeyException异常，首先就是去数据库确认了有这条数据存在，所以第一个想法是并发导致的，因为有唯一键【某辆车，某个工单，是唯一的】，其余线程插过了，你就插不进去了【比如同一个（或者不同的）预约单找到了同一辆车】
* 2. 刚开始认为是并发问题，所以把判断是否存在，不存在就插入的那段代码加上了synchronize（this）,然后还是不行，想这个是单例，又怀疑spring是不是单例，然而并不行，换成synchronize（.class）还是不行；
* 3. Try catch 抓住异常再查一遍，还是为null,但就是无法插入
* 4. 猜想：这个方法是单线程，但事务是多线程的？有多个线程在执行这个事务，同时存在多个事务：因为事务的隔离性，即使有方法是被锁定的，我确实不能同时两个进入该方法，但是因为事务的隔离，你这个事务没完成前我是看不见的，所以你进了该锁定的方法并且改了数据，但你的事务还没完成，所以我还是看到的是null，而等你出了这个方法，我就可以进去了，所以我无法插入数据
* 5. 于是我在事务那加锁，然后就没有再报错了。分析原因：这种插不进去的case是由于两个不同的预约单（或者相同的）找到了同一辆车，因为两张表都有唯一键，所以这里可以不加锁，抛异常就回滚即可；但是还有种case就是并发处理同一个预约单，然后找到了两辆车，所以还是在处理每一个预约单那里加了锁synchronized。不可避免变成串行 
【能不处理的原因是task-pool和task_main_attribute都有唯一键，它插入会报错，但如果没有唯一键呢，我要保证数据的唯一性。】。
### 4.2 多机并发：测试的时候发现：同一个预约单被处理了两次，生成了两个工单【不同车】，放了两条数据在task_pool，才知道线上是多台机器，要用分布式锁。【预约单id是唯一键哈】
			
## 五、工单系统：工单生成引擎：
* 
工单生成引擎生成短租工单【实质是用的调度工单】，需要把预约单ID传递给用车系统。
5分钟轮询一次b_task_pool查询状态为待处理的记录，根据task_type分别创建对应的工单。创建成功之后，修改该记录为处理中。如果创建失败，则忽略。【调度人员领取工单后，进行车辆巡检，检查不通过会插入b_task_main_attribute里该车的标志.KEY_CANCELLED_BY_TASK为1，占车标签，让调度引擎忽略这辆车，并更新预约表状态为待处理】

工单列表
	1. 调度工单类型不变，文案修改成 短租送车。增加多个属性(从btaskmain_attribute获取)：预约时间／是否超时／剩余分钟／取车距离／送车距离。
	2. 工单列表排序升级，统一到一个排序总逻辑中。短租送车工单排序前置。
	3. 工单领取上限同时只能领取一个。
	4. 工单详情页，增加多个属性：预约时间／剩余分钟／取车距离／送车距离。
	5. 领取之后，开门按钮下移到领取工单位置，上方的功能区只保留锁车和双闪。
	6. 点击开门，开门成功之后，跳转到车辆巡检。根据车辆型号显示不同的检查项。如果有检查不通过的，则跳转到还车页面。增加占车标签。更新b_task_pool 表中特定的处理中的记录更新为待处理。
	7. 还车检查升级。增加提示文案。更改场站弹出提示框。
	8. 还车拍照。在点击还车之后，弹出拍照页面。校验之后才正式完成工单。更新b_task_pool特定记录的状态为已完成，追溯到b_reserve_order更新状态为完成。
	9. 领取工单之后，设置b_task_main_attribute中的status为1已使用。

通知中心：
提供一个push库，对特定的人，发送特定信息的push。
* 1、从taskpool选信息，创建占车调度工单，来源是租车【手动、自动】，创建是用的generate【domino】，创建成功则发送通知，通知工单车辆所在场站的归属区域中或附近3km内的调度员，用的DMC【滴滴消息中心】；更新taskpool状态为Doing；如果创建失败【总共允许失败次数为2】，则要更新预约表状态为待处理，并且插入b_task_main_attribute里该车的标志.KEY_CANCELLED_BY_TASK为1 ，即车辆在异常结束时，设置一个标识，让调度引擎忽略这辆车
2、如果是用户端取消预约单，工单待领取：取消工单，已领取：取消工单，发送消息给进行中的工单领取人，执行中：通知进行中的工单领取人； 设置taskpool中的状态为canceled【已取消】
