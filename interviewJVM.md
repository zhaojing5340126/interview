# 一、深入理解虚拟机之Java内存区域：
## 1、介绍下Java内存区域（运行时数据区）
![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sD4O5ZOeBZiaRDJq1VA8wFqz2BW8LPJU4Cw4hSyZZK0CWJibof9MicmCaeb3xmVDTVfJqJYgC3yYzGOw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
* Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域:
    * 线程共享区
        * 1）方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等等
            * 运行时常量池：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）
        * 2）堆：用于存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
            * 是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）
    * 线程独占区
        * 3）程序计数器：是当前线程所执行的字节码的行号指示器。 
            * 【字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。为了能在线程切换后能恢复到正确的执行位置，所以每条线程都得有一个】
        * 4）Java虚拟机栈：即常说的栈内存。Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出入口等信息。 
            * 局部变量表主要存放了编译器可知的各种数据类型、对象引用
        * 5）本地方法栈：类似Java虚拟机栈。虚拟机栈为虚拟机执行Java方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
        
## 2、对象的访问定位的两种方式
* Java程序通过栈上的引用数据来操作堆上的具体对象。目前主流的对象访问方式有：
    * 使用句柄：
        * 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
        ![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sD4O5ZOeBZiaRDJq1VA8wFqzeVX5DSk1nAnbuwE1UFcfiaiaLoN4nFSXnyDricrG49CadGAmOgpwaVx8Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
    * 直接指针：
        * 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何防止访问类型数据的相关信息，reference中存储的直接就是对象的地址
        ![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sD4O5ZOeBZiaRDJq1VA8wFqzfP0g2FMdicNQBOa7FKQeBiasS5ic9DgaNsMyKqsjZncicx5kRy1cORs4Qg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
    * 各自的优点：
        * 使用句柄来访问的最大好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而引用本身不需要修改。
        * 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

# 二、深入理解虚拟机之垃圾回收

## 1、如何判断对象是否死亡？——引用计数法、可达性分析算法
* 有两种算法判断对象是否死亡：
    * 引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。
        * 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。
    * 可达性分析算法：通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。
    ![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sDOMkMYwE1nhEJFZN46xicicavGRIQiax8E4PaRW4fQxgEeiax0PhqkKD24Y6fG8Ao5WBD0ibVWCoImU7A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 2、简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
* 1) 强引用：我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，垃圾回收器绝不会回收它。
    * 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
* 2）软引用（通过SoftReference类来实现软引用）：如果一个对象只具有软引用，在内存空间足够时，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
    * 只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
* 3) 弱引用（通过WeakReference类来实现弱引用）：如果一个对象只具有弱引用，那么当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
    * 不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
* 4）虚引用（PhantomReference）：无法通过虚引用来取得一个对象实例。为对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
```
## 3、垃圾收集有哪些算法，各自的特点？
* 1） 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
    * 它是最基础的收集算法，存在两大问题：
        * 1：效率问题
        * 2：空间问题（标记清除后会产生大量不连续的碎片）
* 2) 复制算法：为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。
    * 问题：代价是内存缩小为原来的一半
* 3）标记-整理算法：根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
* 4） 分代收集算法：根据对象存活周期的不同将内存分为几块。
    * 优点：一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
        * 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
        * 而老年代的对象存活几率是比较高的所以我们可以选择“标记-清理”或“标记-整理”算法进行垃圾收集。
## 4、HotSpot为什么要分为新生代和老年代？
* 见上分代收集算法的优点
## 5、常见的垃圾回收器有那些？【未】
* 1）Serial收集器：这是一个单线程收集器。
    * 缺点：它只会使用一条垃圾收集线程去完成垃圾收集工作，且它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束
    * 优点：简单高效，因为没有线程交互的开销
![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sDOMkMYwE1nhEJFZN46xicicaLUCFF3pUm6UObRx0nJXvibhjU5uiawbrficoq1a0ZT7YwNI37vOaK8Cdg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
* 2）ParNew收集器：是一个并行收集器【Serial收集器的多线程版本】
    * ，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样
    * 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。
![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sDOMkMYwE1nhEJFZN46xicicat7o1qZPjKhHEkdz7bLgdF86GV8y5W7W14GT4qIYYL5E43hO1hrNINw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
* 3)  Parallel Scavenge收集器【并行清除】：是一个关注吞吐量的并行收集器，是一个使用复制算法的新生代收集器
    * 吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值；而CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。

* 4）Serial Old收集器：Serial收集器的老年代版本，它同样是一个单线程收集器
* 5）Parallel Old收集器：Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。注重吞吐量



* 补充：并行和并发
    * 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
    * 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。
## 6、介绍一下CMS,G1收集器。【未】
* 6）CMS（Concurrent Mark Sweep）收集器：使用标记-清除算法实现，是一种以获取最短回收停顿时间为目标的收集器，注重提高用户体验。
    * 6.1 整个过程分为四步：
        * 初始标记：记录下直接与root相连的对象【 暂停所有的其他线程，速度很快】 ；
        * 并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
        * 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。【这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短】
        * 并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。
    * 6.2 主要优点：并发收集、低停顿。
    * 6.3 主要缺点：对CPU资源敏感；无法处理浮动垃圾；它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sDOMkMYwE1nhEJFZN46xicica99iav0Ja0zDGtUEY1WZ90oGEoW1iblKSEoE78c949AYOe5ZLwRwPKK0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

* 7） G1 (Garbage-First)能以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.【是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器.】
    * G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。
        * 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象。【这一阶段需要停顿线程，但是耗时很短】
        * 并发标记：是从GC Root开始对堆中对象进行可达性分析，找出存活的对象。【这阶段时耗时较长，但可与用户程序并发执行。】
        * 最终标记：是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录。【这一阶段需要停顿线程，但是可并行执行】
        * 筛选回收：在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。
![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sDOMkMYwE1nhEJFZN46xicica4B391DwNetr18NaxrIADHdKMDDZEPGwVjGbtibqsezGF2tegoIJlicvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
## 7、Minor Gc和Full GC 有什么不同呢？
* 新生代GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。当 Eden 空间满时，就将触发一次 Minor GC。
* 老年代GC（Major GC/Full GC）:指发生在老年代的GC，Full GC的速度一般会比Minor GC的慢10倍以上。Full GC产生的原因可能有
    * 1. 调用 System.gc()，会建议虚拟机执行Full GC
        * 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。
    * 2. 老年代空间不足
        * 原因：老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
        * 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间
    * 3. 空间分配担保失败
        * 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。
    * 4. JDK 1.7 及以前的永久代空间不足
        * 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
        * 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
        * 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
    * 5. Concurrent Mode Failure
        * 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

## 8、内存分配与回收策略
* 1) 对象优先在Eden区分配
    * 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。
* 2) 大对象直接进入老年代
    * 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
    * 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
    * -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
* 3) 长期存活的对象将进入老年代
    * 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
    * -XX:MaxTenuringThreshold 用来定义年龄的阈值。
* 4) 动态对象年龄判定：为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果Survivor 空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。
* 5) 空间分配担保
    * 1.在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
    * 2.如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。

# 五、深入理解Java虚拟机之虚拟机类加载机制
* 虚拟机类加载机制：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化。最终形成可以被虚拟机最直接使用的java类型的过程就是虚拟机的类加载机制。
    * 类是在运行期间第一次使用时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。
## 1、简单说说类加载过程，里面执行了哪些操作？
![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sAxRovHTCH3yyW1vpic22WVibSBjZicRXsFogpbuwicqugUaxFaIBQnXxwibQ0XTicKxxCVfb0L8sejJkjw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
* java虚拟机中类加载主要包括：加载、验证、准备、解析和初始化这5个阶段：
    * 1）加载阶段：由三个基本动作组成：

        * 1.1  通过一个类的全限定名来获取定义此类的二进制字节流。
            * （没有指明从哪里获取、怎样获取，可以从zip、网络、运行时计算生成、由其他文件生成等，是一个非常开放的平台）

        * 1.2  将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。

        * 1.3  在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。
    * 2）验证：确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全
        
        * 2.1 验证大概分为四个阶段：文件格式、元数据、字节码、符号引用。
            * 2.1.1 文件格式校验【基于二进制字节流】：验证字节流是否符合class文件的规范，并且能被当前版本的虚拟机处理。
                * 【只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面的3个阶段的全部是基于方法区的存储结构进行的，不会再直接操作字节流】
            * 2.1.2 元数据验证
                 * 对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。【目的是保证不存在不符合Java语言规范的元数据信息。】
            * 2.1.3 字节码验证
                * 该阶段主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为
            * 2.1.4 符号引用验证
                * 最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证的目的是确保解析动作能正常执行。
        * 验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。
    * 3）准备：类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
        * 仅是类变量，不是实例变量，初始值是默认值0或false或null。
            * 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中。实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
        * 如果类变量是常量（final），那么会按照表达式来进行初始化，而不是赋值为 0。public static final int value = 123;
        
    * 4）解析：解析是虚拟机将常量池内的符号引用替换为直接引用的过程。
        * 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
    * 5）初始化：初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 <clinit>() 方法的过程。
        * 类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。
## 2、对类加载器有了解吗？
* 1）对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。
    * 如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。
* 2）类加载器：我们的应用程序都是3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器：
    * 2.1 启动类加载器（Bootstrap ClassLoader）：负责将存放在<JRE_HOME>\lib b目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中
        * （仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）。
    * 2.2 扩展类加载器：负责加载 <JAVA_HOME>/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
    * 2.3 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。
        * 如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
## 3、什么是双亲委派模型？
* 双亲委派模型,要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这里父子关系通常是子类通过组合关系而不是继承关系来复用父加载器的代码。
![](https://mmbiz.qpic.cn/mmbiz_png/hvUCbRic69sAxRovHTCH3yyW1vpic22WVibsIR7t9TpI4LlxD1hewI5HEy12YhMNtaFohOVOxibnrxCWpXic8Aib9VibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
## 4、双亲委派模型的工作过程以及使用它的好处。
* 双亲委派模型的工作过程： 如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成（所以所有的加载请求最终都应该传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去加载。
* 一个显而易见的好处就是java类随着它的类加载器一起具备了一种带有优先级的层次关系。
    * 例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。