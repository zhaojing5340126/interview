<!-- TOC -->

- [1. 前言](#1-前言)
- [4. * 二维数组中的查找](#4--二维数组中的查找)
    - [题目描述](#题目描述)
    - [解题思路](#解题思路)
- [6. *从尾到头打印链表【实际就是反转链表】](#6-从尾到头打印链表实际就是反转链表)
    - [题目描述](#题目描述-1)
    - [解题思路](#解题思路-1)
        - [原地反转【最优解】](#原地反转最优解)
        - [使用栈](#使用栈)
        - [使用递归](#使用递归)
        - [使用 Collections.reverse()](#使用-collectionsreverse)
- [8. * 二叉树的下一个结点](#8--二叉树的下一个结点)
    - [题目描述](#题目描述-2)
    - [解题思路](#解题思路-2)
- [9. * 用两个栈实现队列](#9--用两个栈实现队列)
    - [题目描述](#题目描述-3)
    - [解题思路](#解题思路-3)
- [10.1 * 斐波那契数列](#101--斐波那契数列)
    - [题目描述](#题目描述-4)
    - [解题思路](#解题思路-4)
- [10.2 * 跳台阶](#102--跳台阶)
    - [题目描述](#题目描述-5)
    - [解题思路](#解题思路-5)
- [10.3 矩形覆盖](#103-矩形覆盖)
    - [题目描述](#题目描述-6)
    - [解题思路](#解题思路-6)
- [10.4 * 变态跳台阶](#104--变态跳台阶)
    - [题目描述](#题目描述-7)
    - [解题思路](#解题思路-7)
- [11. 旋转数组的最小数字](#11-旋转数组的最小数字)
    - [题目描述](#题目描述-8)
    - [解题思路](#解题思路-8)
- [12.*  矩阵中的路径](#12--矩阵中的路径)
    - [题目描述](#题目描述-9)
    - [解题思路](#解题思路-9)
- [13. * 机器人的运动范围](#13--机器人的运动范围)
    - [题目描述](#题目描述-10)
    - [解题思路](#解题思路-10)
- [14. 剪绳子](#14-剪绳子)
    - [题目描述](#题目描述-11)
    - [解题思路](#解题思路-11)
        - [贪心](#贪心)
        - [动态规划](#动态规划)
- [17. 打印从 1 到最大的 n 位数](#17-打印从-1-到最大的-n-位数)
    - [题目描述](#题目描述-12)
    - [解题思路](#解题思路-12)
- [18.1 在 O(1) 时间内删除链表节点](#181-在-o1-时间内删除链表节点)
    - [解题思路](#解题思路-13)
- [20. 表示数值的字符串](#20-表示数值的字符串)
    - [题目描述](#题目描述-13)
    - [解题思路](#解题思路-14)
- [21. * 调整数组顺序使奇数位于偶数前面](#21--调整数组顺序使奇数位于偶数前面)
    - [题目描述](#题目描述-14)
    - [解题思路](#解题思路-15)
- [24. 反转链表](#24-反转链表)
    - [解题思路](#解题思路-16)
        - [递归](#递归)
        - [迭代](#迭代)
- [25. * 合并两个排序的链表](#25--合并两个排序的链表)
    - [题目描述](#题目描述-15)
    - [解题思路](#解题思路-17)
        - [递归](#递归-1)
        - [迭代](#迭代-1)
- [27. * 二叉树的镜像](#27--二叉树的镜像)
    - [题目描述](#题目描述-16)
    - [解题思路](#解题思路-18)
- [28 * 对称的二叉树](#28--对称的二叉树)
    - [题目描述](#题目描述-17)
    - [解题思路](#解题思路-19)
- [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
    - [题目描述](#题目描述-18)
    - [解题思路](#解题思路-20)
- [30. * 包含 min 函数的栈](#30--包含-min-函数的栈)
    - [题目描述](#题目描述-19)
    - [解题思路](#解题思路-21)
- [32.1 * 从上往下打印二叉树](#321--从上往下打印二叉树)
    - [题目描述](#题目描述-20)
    - [解题思路](#解题思路-22)
- [32.2 * 把二叉树打印成多行](#322--把二叉树打印成多行)
    - [题目描述](#题目描述-21)
    - [解题思路](#解题思路-23)
- [32.3 * 按之字形顺序打印二叉树](#323--按之字形顺序打印二叉树)
    - [题目描述](#题目描述-22)
    - [解题思路](#解题思路-24)
- [35. * 复杂链表的复制](#35--复杂链表的复制)
    - [题目描述](#题目描述-23)
    - [解题思路](#解题思路-25)
- [37. * 序列化二叉树](#37--序列化二叉树)
    - [题目描述](#题目描述-24)
    - [解题思路](#解题思路-26)
- [38.* 字符串的排列](#38-字符串的排列)
    - [题目描述](#题目描述-25)
    - [解题思路](#解题思路-27)
- [39. * 数组中出现次数超过一半的数字](#39--数组中出现次数超过一半的数字)
    - [解题思路](#解题思路-28)
- [51 * 字符流中第一个不重复的字符](#51--字符流中第一个不重复的字符)
    - [题目描述](#题目描述-26)
    - [解题思路](#解题思路-29)
- [42. *  连续子数组的最大和](#42---连续子数组的最大和)
    - [题目描述](#题目描述-27)
    - [解题思路](#解题思路-30)
- [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
    - [题目描述](#题目描述-28)
    - [解题思路](#解题思路-31)
- [* 45. 把数组排成最小的数](#-45-把数组排成最小的数)
    - [题目描述](#题目描述-29)
    - [解题思路](#解题思路-32)
- [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
    - [题目描述](#题目描述-30)
    - [解题思路](#解题思路-33)
- [47. 礼物的最大价值](#47-礼物的最大价值)
    - [题目描述](#题目描述-31)
    - [解题思路](#解题思路-34)
- [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
    - [题目描述](#题目描述-32)
    - [解题思路](#解题思路-35)
- [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
    - [题目描述](#题目描述-33)
    - [解题思路](#解题思路-36)
- [51.*  数组中的逆序对](#51--数组中的逆序对)
    - [题目描述](#题目描述-34)
    - [解题思路](#解题思路-37)
- [52. * 两个链表的第一个公共结点](#52--两个链表的第一个公共结点)
    - [题目描述](#题目描述-35)
    - [解题思路](#解题思路-38)
- [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)
    - [解题思路](#解题思路-39)
- [55.1 *  二叉树的深度](#551---二叉树的深度)
    - [题目描述](#题目描述-36)
    - [解题思路](#解题思路-40)
- [55.2 * 平衡二叉树](#552--平衡二叉树)
    - [题目描述](#题目描述-37)
    - [解题思路](#解题思路-41)
- [57.1 * 和为 S 的两个数字](#571--和为-s-的两个数字)
    - [题目描述](#题目描述-38)
    - [解题思路](#解题思路-42)
- [58.2 * 左旋转字符串](#582--左旋转字符串)
    - [题目描述](#题目描述-39)
    - [解题思路](#解题思路-43)
- [60. n 个骰子的点数](#60-n-个骰子的点数)
    - [题目描述](#题目描述-40)
    - [解题思路](#解题思路-44)
        - [动态规划解法](#动态规划解法)
        - [动态规划解法 + 旋转数组](#动态规划解法--旋转数组)
- [61. * 扑克牌顺子](#61--扑克牌顺子)
    - [题目描述](#题目描述-41)
    - [解题思路](#解题思路-45)
- [63. 股票的最大利润](#63-股票的最大利润)
    - [题目描述](#题目描述-42)
    - [解题思路](#解题思路-46)
- [67. * 把字符串转换成整数](#67--把字符串转换成整数)
    - [题目描述](#题目描述-43)
    - [解题思路](#解题思路-47)
- [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
    - [解题思路](#解题思路-48)
        - [二叉查找树](#二叉查找树)
        - [普通二叉树](#普通二叉树)
- [参考文献](#参考文献)

<!-- /TOC -->

# 1. 前言

本文的绘图可通过以下途径免费获得并使用：

- [ProcessOn](https://www.processon.com/view/5a3e4c7be4b0909c1aa18b49)
- [DrawIO](https://drive.google.com/file/d/1nSSCpPUC05MFoeFuf_aeTtkm7dG5-bJ1/view?usp=sharing)




# 4. * 二维数组中的查找

[NowCoder](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

## 解题思路

从右上角开始查找。矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。

复杂度：O(M + N) + O(1)

当前元素的查找区间为左下角的所有元素，例如元素 12 的查找区间如下：

<div align="center"> <img src="../pics//f94389e9-55b1-4f49-9d37-00ed05900ae0.png" width="250"/> </div><br>

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```


# 6. *从尾到头打印链表【实际就是反转链表】

[NowCoder](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入链表的第一个节点，从尾到头反过来打印出每个结点的值。

<div align="center"> <img src="../pics//d99dc9e2-197c-4085-813d-7195da1c6762.png" width="300"/> </div><br>

## 解题思路
### 原地反转【最优解】
```Java
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode head) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        ListNode newHead = reverseList(head);
        ListNode cur = newHead;
        while(cur!=null){
            list.add(cur.val);
            cur = cur.next;
        }
        return list;
    }
    
    public ListNode reverseList(ListNode head){
        ListNode pre = null;
        ListNode next = null;
        while (head != null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```

### 使用栈

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    Stack<Integer> stack = new Stack<>();
    while (listNode != null) {
        stack.add(listNode.val);
        listNode = listNode.next;
    }
    ArrayList<Integer> ret = new ArrayList<>();
    while (!stack.isEmpty())
        ret.add(stack.pop());
    return ret;
}
```

### 使用递归

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> ret = new ArrayList<>();
    if (listNode != null) {
        ret.addAll(printListFromTailToHead(listNode.next));
        ret.add(listNode.val);
    }
    return ret;
}
```

### 使用 Collections.reverse()

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> ret = new ArrayList<>();
    while (listNode != null) {
        ret.add(listNode.val);
        listNode = listNode.next;
    }
    Collections.reverse(ret);
    return ret;
}
```



# 8. * 二叉树的下一个结点

[NowCoder](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

```java
public class TreeLinkNode {

    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
```

## 解题思路

① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；

<div align="center"> <img src="../pics//cb0ed469-27ab-471b-a830-648b279103c8.png" width="250"/> </div><br>

② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。

<div align="center"> <img src="../pics//e143f6da-d114-4ba4-8712-f65299047fa2.png" width="250"/> </div><br>

```java
public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if (pNode.right != null) {
        TreeLinkNode node = pNode.right;
        while (node.left != null)
            node = node.left;
        return node;
    } else {
        while (pNode.next != null) {
            TreeLinkNode parent = pNode.next;
            if (parent.left == pNode)
                return parent;
            pNode = pNode.next;
        }
    }
    return null;
}
```

# 9. * 用两个栈实现队列

[NowCoder](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

## 解题思路

in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。

<div align="center"> <img src="../pics//5acf7550-86c5-4c5b-b912-8ce70ef9c34e.png" width="400"/> </div><br>

```java
Stack<Integer> in = new Stack<Integer>();
Stack<Integer> out = new Stack<Integer>();

public void push(int node) {
    in.push(node);
}

public int pop() throws Exception {  //***要在这先弄throws才能throw
    if (out.isEmpty())
        while (!in.isEmpty())
            out.push(in.pop());

    if (out.isEmpty())
        throw new Exception("queue is empty");  //***需要new，别忘了

    return out.pop();
}
```

# 10.1 * 斐波那契数列

[NowCoder](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

求斐波那契数列的第 n 项，n <= 39。

<div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right."/></div> <br>

## 解题思路

如果使用递归求解，会重复计算一些子问题。例如，计算 f(10) 需要计算 f(9) 和 f(8)，计算 f(9) 需要计算 f(8) 和 f(7)，可以看到 f(8) 被重复计算了。

<div align="center"> <img src="../pics//faecea49-9974-40db-9821-c8636137df61.jpg" width="300"/> </div><br>

递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int[] fib = new int[n + 1];
    fib[1] = 1;
    for (int i = 2; i <= n; i++)
        fib[i] = fib[i - 1] + fib[i - 2];
    return fib[n];
}
```

考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。

```java
public int Fibonacci(int n) {
    if (n <= 1)
        return n;
    int pre2 = 0, pre1 = 1;
    int fib = 0;
    for (int i = 2; i <= n; i++) {
        fib = pre2 + pre1;
        pre2 = pre1;
        pre1 = fib;
    }
    return fib;
}
```

由于待求解的 n 小于 40，因此可以将前 40 项的结果先进行计算，之后就能以 O(1) 时间复杂度得到第 n 项的值了。

```java
public class Solution {

    private int[] fib = new int[40];

    public Solution() {
        fib[1] = 1;
        fib[2] = 2;
        for (int i = 2; i < fib.length; i++)
            fib[i] = fib[i - 1] + fib[i - 2];
    }

    public int Fibonacci(int n) {
        return fib[n];
    }
}
```

# 10.2 * 跳台阶

[NowCoder](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

## 解题思路

```java 
//递归版本 500ms
public class Solution {
    public int JumpFloor(int target) {
        if(target == 1){  //还剩1个台阶没跳
            return 1;
        }
        if(target == 2){  //还剩两个台阶
            return 2;
        }
        return JumpFloor(target-1) + JumpFloor(target-2);  //青蛙又跳了一步或者两步
    }
}


//动态规划版本 20ms
public class Solution {
    public int JumpFloor(int target){
        if(target <= 2)
            return target;
        int[] dp=new int[target+1];
        dp[target] = 0;
        dp[target-1] = 1;
        dp[target-2] = 2;
        for(int pre = target-3; pre>=0 ;pre--){
            dp[pre] = dp[pre+1]+dp[pre+2];
        }
        return dp[0];
    }
}

```

# 10.3 矩形覆盖

[NowCoder](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

我们可以用 2\*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共有多少种方法？

## 解题思路
* 【分析】:既然是长条形的，那么从后向前，只有两种情况：
    * 情况一：最后剩一个一列的长方形，则方法有RectCover(target-1)种
    * 最后剩一个2列的正方形，这个正方形有两种放法，两个一列的矩形横着放，两个一列的矩形竖着放，但是竖着放实际也归为情况一【最后剩一个一列的长方形】，所以不能*2

```java
//递归方法
public class Solution {
    public int RectCover(int target) {
        if(target <= 2){
            return target;
        }
        return RectCover(target-1) + RectCover(target-2);
    }
}

//动态递归
public int RectCover(int n) {
    if (n <= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 0;
    for (int i = 3; i <= n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}
```

# 10.4 * 变态跳台阶

[NowCoder](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


## 题目描述

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

## 解题思路
* 【分析】：

    * 跳上一个n级的台阶一共有f(n)种跳法：第一跳跳1个台阶，跳2个、跳3个、......跳n个，则得出结论：
    *  f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)

    * f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) => f(0) + f(1) + f(2) + f(3) + ... +f(n-2) + f(n-1)
    * 所以 f(n) = 2*f(n-1)

```java
//递归版本
public class Solution {
    public int JumpFloorII(int target) {
        if(target == 0 )
            return 0;
        if(target == 1){
            return 1;
        }
        return 2*JumpFloorII(target-1);
    }
}

//动态规划版本
public class Solution {
    public int JumpFloorII(int target) {
        if(target <= 1 ){
             return 1; 
        }
        int pre = 1;
        int result = 2;
        for(int i=2; i<=target; i++){
            result = 2*pre;
            pre = result;
        }
        return result;
    }
}
```


# 11. 旋转数组的最小数字

[NowCoder](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。

例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。

## 解题思路

在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为 O(logN)。

本题可以修改二分查找算法进行求解：

- 当 nums[m] <= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m；
- 否则解在 [m + 1, h] 之间，令 l = m + 1。

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}
```

如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。

```java
public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[l] == nums[m] && nums[m] == nums[h])
            return minNumber(nums, l, h);
        else if (nums[m] <= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}

private int minNumber(int[] nums, int l, int h) {
    for (int i = l; i < h; i++)
        if (nums[i] > nums[i + 1])
            return nums[i + 1];
    return nums[l];
}
```

# 12.*  矩阵中的路径

[NowCoder](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

例如下面的矩阵包含了一条 bfce 路径。

<div align="center"> <img src="../pics//e31abb94-9201-4e06-9902-61101b92f475.png" width="300"/> </div><br>

## 解题思路

```java
public class Solution {
    public boolean hasPath(char[] m, int rows, int cols, char[] str)
    {
        if(str == null||str.length==0){
            return true;
        }
        if(m == null){
            return false;
        }
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(str[0]==m[i*cols+j]){
                    boolean[][] status = new boolean[rows][cols];
                    boolean s = hasPath(m,rows,cols,i,j,str,0,status);
                    if(s){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    private boolean hasPath(char[] m ,int rows,int cols,int i,int j,char[] str,int cur,boolean[][] status){
        if(cur == str.length){
            return true;
        }
        if(i>=0&&i<rows&& j>=0 && j<cols){
            if(status[i][j]!= true && str[cur]==m[i*cols+j]){
                status[i][j] = true;
                boolean up = hasPath(m,rows,cols,i-1,j,str,cur+1,status);
                boolean down = hasPath(m,rows,cols,i+1,j,str,cur+1,status);
                boolean left = hasPath(m,rows,cols,i,j-1,str,cur+1,status);
                boolean right = hasPath(m,rows,cols,i,j+1,str,cur+1,status);
                status[i][j]=false;
                return up||down||left||right;
            }else{
                return false;
            }
        }
        return false;
    }

}
```

# 13. * 机器人的运动范围

[NowCoder](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,37)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

## 解题思路

```java
public class Solution {
    public int movingCount(int k, int rows, int cols)
    {
        if(k<0||rows<0||cols<0){
            return 0;
        }
        boolean[][] s = new boolean[rows][cols];
        return count(k,rows,cols,0,0,s);
    }
    
    private int count(int k,int rows,int cols,int i,int j,boolean[][] s){
        if(i>=0&&i<rows&&j>=0&&j<cols){
            if(s[i][j] == false && countSum(i,j)<=k){
                s[i][j]=true;
                return 1+count(k,rows,cols,i-1,j,s)
                    +count(k,rows,cols,i+1,j,s)
                    +count(k,rows,cols,i,j-1,s)
                    +count(k,rows,cols,i,j+1,s);
            }
        }
        return 0;
    }
    
        private int countSum(int i,int j){
        return sum(i)+sum(j);
    }
    private int sum(int i){
        int sum=0;
        while(i!=0){
            sum+=i%10;
            i/=10;
        }
        return sum;
    }
}
```


# 14. 剪绳子

[Leetcode](https://leetcode.com/problems/integer-break/description/)

## 题目描述

把一根绳子剪成多段，并且使得每段的长度乘积最大。

```html
n = 2
return 1 (2 = 1 + 1)

n = 10
return 36 (10 = 3 + 3 + 4)
```

## 解题思路

### 贪心

尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。

证明：当 n >= 5 时，3(n - 3) - 2(n - 2) = n - 5 >= 0。因此把长度大于 5 的绳子切成两段，令其中一段长度为 3 可以使得两段的乘积最大。

```java
public int integerBreak(int n) {
    if (n < 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}
```

### 动态规划

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 1; j < i; j++)
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}
```





# 17. 打印从 1 到最大的 n 位数

## 题目描述

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

## 解题思路

由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

使用回溯法得到所有的数。

```java
public void print1ToMaxOfNDigits(int n) {
    if (n <= 0)
        return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, 0);
}

private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length) {
        printNumber(number);
        return;
    }
    for (int i = 0; i < 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}

private void printNumber(char[] number) {
    int index = 0;
    while (index < number.length && number[index] == '0')
        index++;
    while (index < number.length)
        System.out.print(number[index++]);
    System.out.println();
}
```

# 18.1 在 O(1) 时间内删除链表节点

## 解题思路

① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。

<div align="center"> <img src="../pics//27ff9548-edb6-4465-92c8-7e6386e0b185.png" width="600"/> </div><br>

② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

<div align="center"> <img src="../pics//280f7728-594f-4811-a03a-fa8d32c013da.png" width="600"/> </div><br>

综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N \~ 2，因此该算法的平均时间复杂度为 O(1)。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if (head == null || tobeDelete == null)
        return null;
    if (tobeDelete.next != null) {
        // 要删除的节点不是尾节点
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    } else {
        ListNode cur = head;
        while (cur.next != tobeDelete)
            cur = cur.next;
        cur.next = null;
    }
    return head;
}
```




# 20. 表示数值的字符串

[NowCoder](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

```html
true

"+100"
"5e2"
"-123"
"3.1416"
"-1E-16"

false

"12e"
"1a3.14"
"1.2.3"
"+-5"
"12e+4.3"
```


## 解题思路

使用正则表达式进行匹配。

```html
[]  ： 字符集合
()  ： 分组
?   ： 有或无
+   ： 重复 1 ~ n
*   ： 重复 0 ~ n
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字
```

```java
public boolean isNumeric(char[] str) {
    if (str == null || str.length == 0)
        return false;
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
}
```

# 21. * 调整数组顺序使奇数位于偶数前面

[NowCoder](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。

## 解题思路

```java
import java.util.*;

public class Solution {
    public void reOrderArray(int [] array) {
        if(array == null || array.length<2)
            return;
        Queue<Integer> odd = new LinkedList<>();
        Queue<Integer> even = new LinkedList<>();
        for(int i = 0; i<array.length; i++){
            if( （array[i] % 2） != 0  ){//奇数
                odd.add(array[i]);
            }else{
                even.add(array[i]);
            }
        }
        int i =0;
        while(!odd.isEmpty()){
            array[i++] = odd.poll();
        }
         while(!even.isEmpty()){
            array[i++] = even.poll();
        }
    }

}
```





# 24. 反转链表

[NowCoder](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路

### 递归

```java
public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode next = head.next;
    head.next = null;
    ListNode newHead = ReverseList(next);
    next.next = head;
    return newHead;
}
```

### 迭代

```java
public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}
```

# 25. * 合并两个排序的链表

[NowCoder](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//43f2cafa-3568-4a89-a895-4725666b94a6.png" width="500"/> </div><br>

## 解题思路

### 递归

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    if (list1 == null)
        return list2;
    if (list2 == null)
        return list1;
    if (list1.val <= list2.val) {
        list1.next = Merge(list1.next, list2);
        return list1;
    } else {
        list2.next = Merge(list1, list2.next);
        return list2;
    }
}
```

### 迭代

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    if (list1 != null)
        cur.next = list1;
    if (list2 != null)
        cur.next = list2;
    return head.next;
}
```


# 27. * 二叉树的镜像

[NowCoder](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//a2d13178-f1ef-4811-a240-1fe95b55b1eb.png" width="300"/> </div><br>

## 解题思路

```java
public class Solution {
    public void Mirror(TreeNode root) {
        if(root == null){
            return;
        }
        exchangeLeftAndRight(root);
    }
    
    private TreeNode exchangeLeftAndRight(TreeNode root ){
        if(root == null){
            return null;
        }
        TreeNode left = exchangeLeftAndRight(root.left);
        TreeNode right = exchangeLeftAndRight(root.right);
        root.left=right;
        root.right = left;
        return root;
    }
}
```

# 28 * 对称的二叉树

[NowCder](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//f42443e0-208d-41ea-be44-c7fd97d2e3bf.png" width="300"/> </div><br>

## 解题思路

```java
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null)
        return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}

boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null)
        return true;
    if (t1 == null || t2 == null)
        return false;
    if (t1.val != t2.val)
        return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}
```

# 29. 顺时针打印矩阵

[NowCoder](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<div align="center"> <img src="../pics//6539b9a4-2b24-4d10-8c94-2eb5aba1e296.png" width="300"/> </div><br>

## 解题思路

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] m) {
        if(m==null || m.length == 0|| m[0].length==0)
            return null;
        ArrayList<Integer> result = new ArrayList<>();
        int a=0,b=0,c=m.length-1,d=m[0].length-1;
        for(;a<=c && b<=d; a++,b++,c--,d--){  //a<=c && b<=d这两个都必须要，才能保证数组不越界
            result.addAll(printCycle(m,a,b,c,d));
        }
        return result;  
    }
    private ArrayList<Integer> printCycle(int[][] m,int a, int b,int c,int d){
        ArrayList<Integer> result = new ArrayList<>();
        if(a == c){
            for(; b<=d; b++){
                result.add(m[a][b]);
            }
            return result;
        }
        if(b == d){
            for(; a <= c; a++){
                result.add(m[a][b]);
            }
            return result;
        }
        
        for(int j = b; j<d; j++){
            result.add(m[a][j]);
        }
        for(int i=a; i<c; i++){
            result.add(m[i][d]);
        }
        for(int j=d; j>b; j--){
            result.add(m[c][j]);
        }
        for(int i=c; i>a; i--){
            result.add(m[i][b]);
        }
        return result;
    }
}
```

# 30. * 包含 min 函数的栈

[NowCoder](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

## 解题思路

```java
private Stack<Integer> dataStack = new Stack<>();
private Stack<Integer> minStack = new Stack<>();

public void push(int node) {
    dataStack.push(node);
    minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));
}

public void pop() {
    dataStack.pop();
    minStack.pop();
}

public int top() {
    return dataStack.peek();
}

public int min() {
    return minStack.peek();
}
```



# 32.1 * 从上往下打印二叉树

[NowCoder](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7

<div align="center"> <img src="../pics//348bc2db-582e-4aca-9f88-38c40e9a0e69.png" width="250"/> </div><br>

## 解题思路

使用队列来进行层次遍历。

不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。

```java
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode head) {
        ArrayList<Integer> result = new ArrayList<>();
        if(head == null){
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(head);
        while(!queue.isEmpty()){
            head = queue.poll();
            result.add(head.val);
            if(head.left != null){
                queue.add(head.left);
            }
            if(head.right != null){
                queue.add(head.right);
            }
        }
        return result;
    }
}
```

# 32.2 * 把二叉树打印成多行

[NowCoder](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

和上题几乎一样。

## 解题思路

```java
ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    while (!queue.isEmpty()) {
        ArrayList<Integer> list = new ArrayList<>();
        int cnt = queue.size();
        while (cnt-- > 0) {
            TreeNode node = queue.poll();
            if (node == null)
                continue;
            list.add(node.val);
            queue.add(node.left);
            queue.add(node.right);
        }
        if (list.size() != 0)
            ret.add(list);
    }
    return ret;
}
```

# 32.3 * 按之字形顺序打印二叉树

[NowCoder](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

## 解题思路

```java
public class Solution {
    ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer> >();
    public ArrayList<ArrayList<Integer> > Print(TreeNode root) {
        if(root == null){
            return res;
        }
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        s1.push(root);
        while(!s1.isEmpty() || !s2.isEmpty()){
            if(!s1.isEmpty()){
                ArrayList<Integer> temp = new ArrayList<>();
                while(!s1.isEmpty()){
                    TreeNode node = s1.pop();
                    temp.add(node.val);
                    if(node.left != null){
                        s2.push(node.left);
                    }
                    if(node.right !=null){
                        s2.push(node.right);
                    }
                }
                res.add(temp);
            }else{
                ArrayList<Integer> temp = new ArrayList<>();
                while(!s2.isEmpty()){
                    TreeNode node = s2.pop();
                    temp.add(node.val);
                    if(node.right!= null){
                        s1.push(node.right);
                    }
                    if(node.left !=null){
                        s1.push(node.left);
                    }
                }
                res.add(temp);
            }
        }
          return res;
    }

}
```




# 35. * 复杂链表的复制

[NowCoder](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。

```java
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
```


## 解题思路

第一步，在每个节点的后面插入复制的节点。

第二步，对复制节点的 random 链接进行赋值。

第三步，拆分。

```java
public RandomListNode Clone(RandomListNode pHead) {
    if (pHead == null)
        return null;
    // 插入新节点
    RandomListNode cur = pHead;
    while (cur != null) {
        RandomListNode clone = new RandomListNode(cur.label);
        clone.next = cur.next;
        cur.next = clone;
        cur = clone.next;
    }
    // 建立 random 链接
    cur = pHead;
    while (cur != null) {
        RandomListNode clone = cur.next;
        if (cur.random != null)
            clone.random = cur.random.next;
        cur = clone.next;
    }
    // 拆分
    cur = pHead;
    RandomListNode pCloneHead = pHead.next;
    while (cur.next != null) {
        RandomListNode next = cur.next;
        cur.next = next.next;
        cur = next;
    }
    return pCloneHead;
}
```



# 37. * 序列化二叉树

[NowCoder](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请实现两个函数，分别用来序列化和反序列化二叉树。

## 解题思路

```java
private String deserializeStr;

public String Serialize(TreeNode root) {
    if (root == null)
        return "#";
    return root.val + " " + Serialize(root.left) + " " + Serialize(root.right);
}

public TreeNode Deserialize(String str) {
    deserializeStr = str;
    return Deserialize();
}

private TreeNode Deserialize() {
    if (deserializeStr.length() == 0)
        return null;
    int index = deserializeStr.indexOf(" ");
    String node = index == -1 ? deserializeStr : deserializeStr.substring(0, index);
    deserializeStr = index == -1 ? "" : deserializeStr.substring(index + 1);
    if (node.equals("#"))
        return null;
    int val = Integer.valueOf(node);
    TreeNode t = new TreeNode(val);
    t.left = Deserialize();
    t.right = Deserialize();
    return t;
}
```

```java
//层序遍历的实现方法
public class Solution {
    String Serialize(TreeNode root) {
        if(root == null){
            return null;
        }
        StringBuffer s = new StringBuffer();
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        s.append(String.valueOf(root.val));
        s.append("_");
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            if(node.left != null){
                q.offer(node.left);
                s.append(String.valueOf(node.left.val));
                s.append("_");
            }else{
                s.append("#");
                s.append("_");
            }
            if(node.right != null){
                q.offer(node.right);
                s.append(String.valueOf(node.right.val));
                s.append("_");
            }else{
                s.append("#");
                s.append("_");
            }
        }
        return s.toString();
  }
    TreeNode Deserialize(String str) {
       if(str == null){
           return null;
       }
        String[] ch = str.split("_");
        if(ch.length == 0){
            return null;
        }
        int i =0;
        Queue<TreeNode> q = new LinkedList<>();
        TreeNode head = new TreeNode(Integer.parseInt(ch[i++]));
        q.offer(head);
        
        while(!q.isEmpty()){
            TreeNode node = q.poll();
            if(!ch[i].equals("#")){  //*** 不能用 ==
                node.left=new TreeNode(Integer.parseInt(ch[i]));
                q.offer(node.left);
            }
            i++;
            if(!ch[i].equals("#")){
                node.right=new TreeNode(Integer.parseInt(ch[i]));
                q.offer(node.right);
            }
            i++;
        }
        return head;
  }
}
```

# 38.* 字符串的排列

[NowCoder](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。

## 解题思路

```java
private ArrayList<String> ret = new ArrayList<>();

public ArrayList<String> Permutation(String str) {
    if (str.length() == 0)
        return ret;
    char[] chars = str.toCharArray();
    Arrays.sort(chars);
    backtracking(chars, new boolean[chars.length], new StringBuilder());
    return ret;
}

private void backtracking(char[] chars, boolean[] hasUsed, StringBuilder s) {
    if (s.length() == chars.length) {
        ret.add(s.toString());
        return;
    }
    for (int i = 0; i < chars.length; i++) {
        if (hasUsed[i])
            continue;
        if (i != 0 && chars[i] == chars[i - 1] && !hasUsed[i - 1]) /* 保证不重复 */
            continue;
        hasUsed[i] = true;
        s.append(chars[i]);
        backtracking(chars, hasUsed, s);
        s.deleteCharAt(s.length() - 1);
        hasUsed[i] = false;
    }
}
```

# 39. * 数组中出现次数超过一半的数字

[NowCoder](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路
* 【我的】：利用hashmap
```Java
import java.util.*;
import java.lang.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] arr) {
        if(arr == null || arr.length ==0)
            return 0;
        int limit = (arr.length)/2;
        Map<Integer,Integer> map = new HashMap<>();
        for(int i =0; i<arr.length;i++){
            if(map.containsKey(arr[i])){
                map.put(arr[i],map.get(arr[i])+1);
            }else{
                map.put(arr[i],1);
            }
            if(map.get(arr[i]) > limit){
                return arr[i];
            }
        }
        return 0;
    }
}
```

* 【不懂】别人的：多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。

使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。

```java
public int MoreThanHalfNum_Solution(int[] nums) {
    int majority = nums[0];
    for (int i = 1, cnt = 1; i < nums.length; i++) {
        cnt = nums[i] == majority ? cnt + 1 : cnt - 1;
        if (cnt == 0) {
            majority = nums[i];
            cnt = 1;
        }
    }
    int cnt = 0;
    for (int val : nums)
        if (val == majority)
            cnt++;
    return cnt > nums.length / 2 ? majority : 0;
}
```




# 51 * 字符流中第一个不重复的字符

[NowCoder](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。

## 解题思路

```java
import java.util.*;
public class Solution {
    HashMap<Character,Integer> map = new HashMap<>();
    LinkedList<Character> list = new LinkedList<>();
    //Insert one char from stringstream
    public void Insert(char ch)
    {
        if(map.containsKey(ch)){
             map.put(ch,map.get(ch)+1); //不能是++
        }else{
            map.put(ch,1);
        }
       
        list.offer(ch);
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce()
    {
        for(char ch: list){
            if(map.get(ch) == 1){
                return ch;
            }
        }
        return '#';
    }
}
```

# 42. *  连续子数组的最大和

[NowCoder](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。

## 解题思路

```java
import java.util.*;
public class Solution {
    public int FindGreatestSumOfSubArray(int[] arr) {
        int max=Integer.MIN_VALUE;
        int count = 0;
        for(int i=0; i<arr.length;i++){
            count += arr[i];
            if(count > max)
                max =count;
            if(count < 0){
                count =0;
            }
        }
        return max;
    }
}
```



# 44. 数字序列中的某一位数字

## 题目描述

数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。

## 解题思路

```java
public int getDigitAtIndex(int index) {
    if (index < 0)
        return -1;
    int place = 1;  // 1 表示个位，2 表示 十位...
    while (true) {
        int amount = getAmountOfPlace(place);
        int totalAmount = amount * place;
        if (index < totalAmount)
            return getDigitAtIndex(index, place);
        index -= totalAmount;
        place++;
    }
}

/**
 * place 位数的数字组成的字符串长度
 * 10, 90, 900, ...
 */
private int getAmountOfPlace(int place) {
    if (place == 1)
        return 10;
    return (int) Math.pow(10, place - 1) * 9;
}

/**
 * place 位数的起始数字
 * 0, 10, 100, ...
 */
private int getBeginNumberOfPlace(int place) {
    if (place == 1)
        return 0;
    return (int) Math.pow(10, place - 1);
}

/**
 * 在 place 位数组成的字符串中，第 index 个数
 */
private int getDigitAtIndex(int index, int place) {
    int beginNumber = getBeginNumberOfPlace(place);
    int shiftNumber = index / place;
    String number = (beginNumber + shiftNumber) + "";
    int count = index % place;
    return number.charAt(count) - '0';
}
```

# * 45. 把数组排成最小的数

[NowCoder](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。

## 解题思路

可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。

```java
public String PrintMinNumber(int[] numbers) {
    if (numbers == null || numbers.length == 0)
        return "";
    int n = numbers.length;
    String[] nums = new String[n];
    for (int i = 0; i < n; i++)
        nums[i] = numbers[i] + "";
    Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
    String ret = "";
    for (String str : nums)
        ret += str;
    return ret;
}
```

# 46. 把数字翻译成字符串

[Leetcode](https://leetcode.com/problems/decode-ways/description/)

## 题目描述

给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”... 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。

## 解题思路

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0)
        return 0;
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i <= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0)
            dp[i] += dp[i - 1];
        if (s.charAt(i - 2) == '0')
            continue;
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
}
```

# 47. 礼物的最大价值

[NowCoder](https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab)

## 题目描述

在一个 m\*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘

```
1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
```

礼物的最大价值为 1+12+5+7+7+16+5=53。

## 解题思路

应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。

```java
public int getMost(int[][] values) {
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) {
        dp[0] += value[0];
        for (int i = 1; i < n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    }
    return dp[n - 1];
}
```

# 48. 最长不含重复字符的子字符串

## 题目描述

输入一个字符串（只包含 a\~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。

## 解题思路

```java
public int longestSubStringWithoutDuplication(String str) {
    int curLen = 0;
    int maxLen = 0;
    int[] preIndexs = new int[26];
    Arrays.fill(preIndexs, -1);
    for (int curI = 0; curI < str.length(); curI++) {
        int c = str.charAt(curI) - 'a';
        int preI = preIndexs[c];
        if (preI == -1 || curI - preI > curLen) {
            curLen++;
        } else {
            maxLen = Math.max(maxLen, curLen);
            curLen = curI - preI;
        }
        preIndexs[c] = curI;
    }
    maxLen = Math.max(maxLen, curLen);
    return maxLen;
}
```



# 50. 第一个只出现一次的字符位置

[NowCoder](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。

## 解题思路

最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```

以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。

```java
public int FirstNotRepeatingChar2(String str) {
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) && !bs2.get(c))
            bs1.set(c);     // 0 0 -> 0 1
        else if (bs1.get(c) && !bs2.get(c))
            bs2.set(c);     // 0 1 -> 1 1
    }
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) && !bs2.get(c))  // 0 1
            return i;
    }
    return -1;
}
```

# 51.*  数组中的逆序对

[NowCoder](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

## 解题思路

```java
public class Solution {
    public int InversePairs(int [] arr) {
        if(arr == null || arr.length <2)
            return 0;
        return mergeSort(arr,0,arr.length-1);
    }
    
    private int mergeSort(int[] arr,int l,int r){
        if(l == r)
            return 0;
        int mid = l+((r-l)>>1);
        //数值过大，求余
        return (mergeSort(arr,l,mid)+mergeSort(arr,mid+1,r)+merge(arr,l,mid,r))%1000000007;
    }
    
    private int merge(int[] arr,int l ,int mid,int r){
        int p1=l;
        int p2=mid+1;
        int[] help = new int[r-l+1];
        int i=0;
        int res = 0;
        while(p1<=mid && p2<=r){
            res+= (arr[p1] > arr[p2])?(mid-p1+1):0;
            if(res>=1000000007){  //**需要有
                res %=1000000007;
            }
            help[i++]= (arr[p1]<=arr[p2])?arr[p1++]:arr[p2++];
        }
        
        while(p1<=mid){
           help[i++] = arr[p1++];
       }
        while(p2<=r){
            help[i++] = arr[p2++];
        }
        for(i=0; i< help.length; i++){
            arr[l+i] = help[i];
        }
        return res;
    }
}
```

# 52. * 两个链表的第一个公共结点

[NowCoder](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//8f6f9dc9-9ecd-47c8-b50e-2814f0219056.png" width="500"/> </div><br>

## 解题思路

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode l1 = pHead1, l2 = pHead2;
    while (l1 != l2) {
        l1 = (l1 == null) ? pHead2 : l1.next;
        l2 = (l2 == null) ? pHead1 : l2.next;
    }
    return l1;
}
```



# 54. 二叉查找树的第 K 个结点

[NowCoder](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路

利用二叉查找树中序遍历有序的特点。

```java
private TreeNode ret;
private int cnt = 0;

public TreeNode KthNode(TreeNode pRoot, int k) {
    inOrder(pRoot, k);
    return ret;
}

private void inOrder(TreeNode root, int k) {
    if (root == null || cnt >= k)
        return;
    inOrder(root.left, k);
    cnt++;
    if (cnt == k)
        ret = root;
    inOrder(root.right, k);
}
```

# 55.1 *  二叉树的深度

[NowCoder](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

<div align="center"> <img src="../pics//b29f8971-9cb8-480d-b986-0e60c2ece069.png" width="350"/> </div><br>

## 解题思路

```java
import java.util.*;
public class Solution {
    public int TreeDepth(TreeNode root) {
       if(root == null){
           return 0;
       } 
        int leftDep = TreeDepth(root.left);
        int rightDep = TreeDepth(root.right);
        return Math.max(leftDep,rightDep) +1;
    }
}
```

# 55.2 * 平衡二叉树

[NowCoder](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

平衡二叉树左右子树高度差不超过 1。

<div align="center"> <img src="../pics//e026c24d-00fa-4e7c-97a8-95a98cdc383a.png" width="300"/> </div><br>

## 解题思路

```java
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        return high(root) != -1; //-1表示不是平衡二叉树
    }
    
    public int high(TreeNode root){
        if(root == null){
            return 0;
        }
        int l =high(root.left);
        if(l == -1){
            return -1;
        }
        int r =high(root.right);
        if(r == -1){
            return -1;
        }
        if(Math.abs(l-r) > 1){
            return -1;
        }
        return Math.max(l,r)+1;
    }
}
```


# 57.1 * 和为 S 的两个数字

[NowCoder](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。

## 解题思路

使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    int i = 0, j = array.length - 1;
    while (i < j) {
        int cur = array[i] + array[j];
        if (cur == sum)
            return new ArrayList<>(Arrays.asList(array[i], array[j]));
        if (cur < sum)
            i++;
        else
            j--;
    }
    return new ArrayList<>();
}
```



# 58.2 * 左旋转字符串

[NowCoder](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

```html
Input:
S="abcXYZdef"
K=3

Output:
"XYZdefabc"
```

## 解题思路

先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。

```java
import java.util.*;
public class Solution {
    public String LeftRotateString(String str,int n) {
        if(str == null || n<0){
            return null;
        }
        if(str.length()==0){
            return str;
        }
        char[] chars = str.toCharArray();
        int len =chars.length;
        reverse(chars,0,(n%len)-1);
        reverse(chars,(n%len),len-1);
        reverse(chars,0,len-1);
        return String.valueOf(chars);
        
    }
        private void reverse(char[] chars,int i,int j){
        while(i<j){
            swap(chars,i,j);
            i++;
            j--;
        }
    }
    
    private void swap(char[] chars,int i,int j){
        char temp = chars[i];
        chars[i] =chars[j];
        chars[j] = temp;
    }
}
```



# 60. n 个骰子的点数

[Lintcode](https://www.lintcode.com/en/problem/dices-sum/)

## 题目描述

把 n 个骰子仍在地上，求点数和为 s 的概率。

## 解题思路

### 动态规划解法

使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。

空间复杂度：O(N<sup>2</sup>)

```java
public List<Map.Entry<Integer, Double>> dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[n + 1][pointNum + 1];

    for (int i = 1; i <= face; i++)
        dp[1][i] = 1;

    for (int i = 2; i <= n; i++)
        for (int j = i; j <= pointNum; j++)     /* 使用 i 个骰子最小点数为 i */
            for (int k = 1; k <= face && k <= j; k++)
                dp[i][j] += dp[i - 1][j - k];

    final double totalNum = Math.pow(6, n);
    List<Map.Entry<Integer, Double>> ret = new ArrayList<>();
    for (int i = n; i <= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry<>(i, dp[n][i] / totalNum));

    return ret;
}
```

### 动态规划解法 + 旋转数组

空间复杂度：O(N)

```java
public List<Map.Entry<Integer, Double>> dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[2][pointNum + 1];

    for (int i = 1; i <= face; i++)
        dp[0][i] = 1;

    int flag = 1;                                     /* 旋转标记 */
    for (int i = 2; i <= n; i++, flag = 1 - flag) {
        for (int j = 0; j <= pointNum; j++)
            dp[flag][j] = 0;                          /* 旋转数组清零 */

        for (int j = i; j <= pointNum; j++)
            for (int k = 1; k <= face && k <= j; k++)
                dp[flag][j] += dp[1 - flag][j - k];
    }

    final double totalNum = Math.pow(6, n);
    List<Map.Entry<Integer, Double>> ret = new ArrayList<>();
    for (int i = n; i <= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry<>(i, dp[1 - flag][i] / totalNum));

    return ret;
}
```

# 61. * 扑克牌顺子

[NowCoder](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

五张牌，其中大小鬼为癞子，牌面大小为 0。判断这五张牌是否能组成顺子。

## 解题思路

```java
 public static class Solution {
        public static boolean isContinuous(int [] nums) {
            if(nums == null || nums.length<2){
                return true;
            }
            Arrays.sort(nums);
            int count=0;
            int i=0;
            while(nums[i] == 0){
                count++;
                i++;
            }
            int pre=0;
            if(i<nums.length){
                pre = nums[i++];
            }
            for(; i<nums.length; i++){
                if(nums[i] == pre+1){
                    pre = nums[i];
                }else{
                    while (count !=0 && nums[i] != pre+1){  //***
                        count--;
                        pre =pre+1;
                    }
                    if(nums[i] != pre+1){
                        return false;
                    }else {
                        pre = nums[i];
                    }
                }
            }
            return true;

        }
    }
```



# 63. 股票的最大利润

[Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

## 题目描述

可以有一次买入和一次卖出，那么买入必须在前。求最大收益。

## 解题思路

使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0)
        return 0;
    int soFarMin = prices[0];
    int maxProfit = 0;
    for (int i = 1; i < prices.length; i++) {
        soFarMin = Math.min(soFarMin, prices[i]);
        maxProfit = Math.max(maxProfit, prices[i] - soFarMin);
    }
    return maxProfit;
}
```






# 67. * 把字符串转换成整数

[NowCoder](https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。

```html
Iuput:
+2147483647
1a33

Output:
2147483647
0
```

## 解题思路

```java
public int StrToInt(String str) {
    if (str == null || str.length() == 0)
        return 0;
    boolean isNegative = str.charAt(0) == '-';
    int ret = 0;
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (i == 0 && (c == '+' || c == '-'))  /* 符号判定 */
            continue;
        if (c < '0' || c > '9')                /* 非法输入 */
            return 0;
        ret = ret * 10 + (c - '0');
    }
    return isNegative ? -ret : ret;
}
```

# 68. 树中两个节点的最低公共祖先

## 解题思路

### 二叉查找树

<div align="center"> <img src="../pics//293d2af9-de1d-403e-bed0-85d029383528.png" width="300"/> </div><br>

[Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val >= p.val && root.val <= q.val。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null)
        return root;
    if (root.val > p.val && root.val > q.val)
        return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val)
        return lowestCommonAncestor(root.right, p, q);
    return root;
}
```

### 普通二叉树

<div align="center"> <img src="../pics//37a72755-4890-4b42-9eab-b0084e0c54d9.png" width="300"/> </div><br>

[Leetcode : 236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q)
        return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```

# 参考文献

- 何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.
